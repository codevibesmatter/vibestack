/// <reference types="@cloudflare/workers-types" />

import type { Env } from '@repo/shared-types';
import { Client } from '@neondatabase/serverless';

interface ReplicationConfig {
  slot: string;
  publication: string;
  tables: string[];
  neonConnectionString: string;
}

interface WALMessage {
  type: 'insert' | 'update' | 'delete';
  schema: string;
  table: string;
  lsn: string;
  data?: Record<string, any>;
  old?: Record<string, any>;
}

type ReplicationMode = 'initializing' | 'snapshot' | 'streaming' | 'error';

interface ReplicationState {
  mode: ReplicationMode;
  lastLSN: string;
  snapshotComplete: boolean;
  lastHeartbeat: number;
  error?: string;
}

interface ReplicationColumn {
  name: string;
  type: string;
  value: string;
}

export class ReplicationDO implements DurableObject {
  private state: DurableObjectState;
  private env: Env;
  private subscribers: Map<string, WebSocket> = new Map();
  private config: ReplicationConfig;
  private client: Client | null = null;
  private reconnectAttempts = 0;
  private initialized = false;
  private replicationState: ReplicationState = {
    mode: 'initializing',
    lastLSN: '0/0',
    snapshotComplete: false,
    lastHeartbeat: Date.now()
  };

  constructor(state: DurableObjectState, env: Env) {
    this.state = state;
    this.env = env;
    console.log('ReplicationDO: Initializing with state:', { id: state.id });
    this.config = {
      slot: 'vibestack_slot',
      publication: 'vibestack_pub',
      tables: ['User'],
      neonConnectionString: env.DATABASE_URL
    };
    console.log('ReplicationDO: Configuration loaded:', { 
      slot: this.config.slot,
      publication: this.config.publication,
      tables: this.config.tables,
      // Don't log connection string for security
      hasConnectionString: !!this.config.neonConnectionString
    });
  }

  private async init() {
    if (this.initialized) {
      return;
    }

    console.log('ReplicationDO: Starting initialization');
    try {
      // Restore replication state from storage
      const storedState = await this.state.storage.get('replicationState') as ReplicationState | undefined;
      if (storedState) {
        this.replicationState = storedState;
        console.log('ReplicationDO: Restored replication state:', this.replicationState);
      }

      // Initialize client
      this.client = new Client(this.config.neonConnectionString);
      await this.client.connect();
      
      // Set up replication
      await this.setupReplication();

      this.initialized = true;
      console.log('ReplicationDO: Initialization complete');
    } catch (error) {
      console.error('ReplicationDO: Failed to initialize:', error);
      this.replicationState.mode = 'error';
      this.replicationState.error = String(error);
    }
  }

  private async updateReplicationState(updates: Partial<ReplicationState>) {
    this.replicationState = {
      ...this.replicationState,
      ...updates
    };
    await this.state.storage.put('replicationState', this.replicationState);
    console.log('ReplicationDO: Updated replication state:', this.replicationState);
  }

  private async cleanupStaleSlots() {
    if (!this.client) return;

    try {
      // Check for existing slot
      const slots = await this.client.query(
        'SELECT slot_name, active_pid FROM pg_replication_slots WHERE slot_name = $1',
        [this.config.slot]
      );

      if (slots.rows.length > 0) {
        const slot = slots.rows[0];
        if (slot.active_pid) {
          // Check if process is still alive
          const processActive = await this.client.query(
            'SELECT 1 FROM pg_stat_activity WHERE pid = $1',
            [slot.active_pid]
          );
          
          if (processActive.rows.length === 0) {
            try {
              // Process is dead, terminate backend and drop slot
              await this.client.query('SELECT pg_terminate_backend($1)', [slot.active_pid]);
              console.log(`✅ Terminated stale process: ${slot.active_pid}`);
              
              // Drop the slot after terminating the process
              await this.client.query('SELECT pg_drop_replication_slot($1)', [this.config.slot]);
              console.log('✅ Dropped existing slot');
            } catch (terminateError) {
              console.warn('⚠️ Failed to terminate process or drop slot:', terminateError);
            }
          } else {
            console.warn(`⚠️ Slot ${this.config.slot} is in use by active process ${slot.active_pid}`);
          }
        } else {
          // No active PID, safe to drop
          await this.client.query('SELECT pg_drop_replication_slot($1)', [this.config.slot]);
          console.log('✅ Dropped existing slot');
        }
      }
    } catch (error) {
      console.error('❌ Error cleaning up slots:', error);
    }
  }

  private async setupReplication() {
    if (!this.client) return;

    try {
      // Clean up any existing slots first
      await this.cleanupStaleSlots();

      // Ensure publication exists
      try {
        await this.client.query('DROP PUBLICATION IF EXISTS ' + this.config.publication);
      } catch (error) {
        console.warn('⚠️ Failed to drop publication:', error);
      }

      // Create new publication
      await this.client.query('CREATE PUBLICATION ' + this.config.publication + ' FOR TABLE "User"');
      console.log('✅ Publication created');

      // Create new replication slot with wal2json
      await this.client.query(`
        SELECT pg_create_logical_replication_slot($1, 'wal2json');
      `, [this.config.slot]);
      console.log('✅ Created new replication slot with wal2json');

      await this.updateReplicationState({
        mode: 'streaming',
        error: undefined
      });
    } catch (error: any) {
      if (error.code === '55006') {
        console.warn(`⚠️ Slot ${this.config.slot} is already in use, will try to use existing slot`);
      } else {
        console.error('❌ Replication setup failed:', error);
        throw error;
      }
    }
  }

  private async startReplicationLoop() {
    if (!this.client) return;

    let consecutiveErrors = 0;
    const MAX_CONSECUTIVE_ERRORS = 5;

    while (true) {
      try {
        const result = await this.client.query(`
          SELECT * FROM pg_logical_slot_get_changes($1, NULL, NULL,
            'format-version', '2',
            'include-timestamp', 'on',
            'include-transaction', 'on',
            'include-types', 'on',
            'actions', 'insert,update,delete',
            'add-tables', 'public.User'
          );
        `, [this.config.slot]);

        consecutiveErrors = 0;

        if (result.rows.length > 0) {
          for (const change of result.rows) {
            try {
              const data = JSON.parse(change.data);
              
              // Only process actual changes (not begin/commit)
              if (data.action === 'U' || data.action === 'I' || data.action === 'D') {
                // Get the columns from the change data
                let columns = data.columns;

                // For deletes, use the identity field
                if (data.action === 'D' && data.identity) {
                  columns = data.identity;
                }

                const processedChange = {
                  lsn: change.lsn,
                  type: data.action === 'U' ? 'update' : data.action === 'I' ? 'insert' : 'delete',
                  table: data.table,
                  schema: data.schema,
                  timestamp: data.timestamp,
                  data: columns
                };

                await this.broadcastChange(processedChange);
                await this.updateReplicationState({
                  lastLSN: change.lsn,
                  lastHeartbeat: Date.now()
                });
              }
            } catch (e) {
              console.error('Error processing change:', e);
            }
          }
        }

        // Wait before next check
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error: any) {
        consecutiveErrors++;

        if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
          console.error('❌ Too many consecutive errors:', error);
          throw new Error('Too many consecutive errors in replication listener');
        }

        if (error.code === '55006') {
          console.log('⚠️ Replication slot is in use, waiting before retry...');
          await new Promise(resolve => setTimeout(resolve, 5000));
        } else {
          console.error('❌ Error reading changes:', error);
          try {
            await this.setupReplication();
          } catch (setupError) {
            console.error('❌ Failed to recover:', setupError);
          }
          await new Promise(resolve => setTimeout(resolve, 5000));
        }
      }
    }
  }

  private async broadcastChange(change: any) {
    const broadcastMessage = JSON.stringify(change);

    console.log('ReplicationDO: Broadcasting to subscribers:', { 
      subscriberCount: this.subscribers.size,
      messageType: change.type
    });

    for (const [id, socket] of this.subscribers) {
      try {
        socket.send(broadcastMessage);
      } catch (error) {
        console.error('ReplicationDO: Error broadcasting to subscriber:', { id, error });
      }
    }
  }

  // WebSocket lifecycle methods
  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    try {
      console.log('ReplicationDO: Received WebSocket message');
      const data = JSON.parse(message as string);
      
      if (data.type === 'sync') {
        ws.send(JSON.stringify({
          type: 'sync_response',
          lsn: this.replicationState.lastLSN
        }));
      }
    } catch (error) {
      console.error('ReplicationDO: Error handling WebSocket message:', error);
    }
  }

  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) {
    console.log('ReplicationDO: WebSocket closed:', { code, reason, wasClean });
    
    // Remove from subscribers if it's a client connection
    for (const [id, socket] of this.subscribers.entries()) {
      if (socket === ws) {
        this.subscribers.delete(id);
        console.log('ReplicationDO: Removed subscriber:', id);
        break;
      }
    }
  }

  async webSocketError(ws: WebSocket, error: Error) {
    console.error('ReplicationDO: WebSocket error:', error);
  }

  private async handleSubscriberWebSocket(request: Request): Promise<Response> {
    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair);

    // Use hibernation API for client connections
    await this.state.acceptWebSocket(server);

    const subscriberId = crypto.randomUUID();
    this.subscribers.set(subscriberId, server);

    // Send initial state
    server.send(JSON.stringify({
      type: 'connected',
      lsn: this.replicationState.lastLSN
    }));

    // Start replication loop if this is the first subscriber
    if (this.subscribers.size === 1) {
      console.log('ReplicationDO: First subscriber connected, starting replication loop');
      // Start in background
      this.startReplicationLoop().catch(error => {
        console.error('ReplicationDO: Replication loop failed:', error);
      });
    }

    return new Response(null, {
      status: 101,
      webSocket: client
    });
  }

  async fetch(request: Request): Promise<Response> {
    await this.init();

    const url = new URL(request.url);
    
    if (request.headers.get('Upgrade') === 'websocket') {
      if (!request.headers.get('Sec-WebSocket-Version') || !request.headers.get('Sec-WebSocket-Key')) {
        return new Response('Expected WebSocket headers', { status: 400 });
      }

      if (url.pathname === '/subscribe') {
        return this.handleSubscriberWebSocket(request);
      }

      return new Response('Invalid WebSocket endpoint', { status: 400 });
    }

    if (url.pathname === '/status') {
      return new Response(JSON.stringify({
        subscribers: this.subscribers.size,
        lastLSN: this.replicationState.lastLSN,
        walConnected: !!this.client,
        reconnectAttempts: this.reconnectAttempts,
        initialized: this.initialized,
        mode: this.replicationState.mode,
        snapshotComplete: this.replicationState.snapshotComplete,
        lastHeartbeat: this.replicationState.lastHeartbeat,
        error: this.replicationState.error
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    return new Response('Invalid request', { status: 400 });
  }
} 