{
  "version": 3,
  "sources": ["../src/validation/services.ts", "../src/validation/openapi.ts", "../src/validation/type-guards.ts", "../src/validation/validators.ts", "../src/validation/schemas.ts", "../src/error/tracking.ts", "../src/error/types.ts", "../src/serialization/core/utils.ts"],
  "sourcesContent": ["/**\n * Service configuration options\n */\nexport interface ServiceConfig {\n  tableName?: string;\n  strict?: boolean;\n  enableMetrics?: boolean;\n}\n\n/**\n * Service metrics tracking\n */\nexport interface ServiceMetrics {\n  operations: number;\n  errors: number;\n  lastOperation?: {\n    name: string;\n    timestamp: number;\n    duration: number;\n  };\n}\n\n/**\n * Service error types\n */\nexport enum ServiceErrorType {\n  VALIDATION = 'VALIDATION',\n  NOT_FOUND = 'NOT_FOUND',\n  INTERNAL = 'INTERNAL',\n  UNAUTHORIZED = 'UNAUTHORIZED',\n  FORBIDDEN = 'FORBIDDEN',\n  CONFLICT = 'CONFLICT',\n  UNKNOWN = 'UNKNOWN'\n}\n\n/**\n * Service error with type information\n */\nexport class ServiceError extends Error {\n  constructor(\n    public readonly type: ServiceErrorType,\n    message: string\n  ) {\n    super(message);\n    this.name = 'ServiceError';\n  }\n}\n\n/**\n * Base success response type with literal true\n */\nexport type SuccessResponse<T> = {\n  success: true;\n  data: T;\n};\n\n/**\n * Base error response type with literal false\n */\nexport type ErrorResponse<T extends ServiceErrorType = ServiceErrorType> = {\n  success: false;\n  error: {\n    type: T;\n    message: string;\n  };\n};\n\n/**\n * Service operation result type with specific error types\n */\nexport type ServiceResult<T, E extends ServiceErrorType = ServiceErrorType> = \n  | SuccessResponse<T>\n  | ErrorResponse<E>;\n\n/**\n * HTTP status codes mapped to error types\n */\nexport const ErrorTypeToStatus = {\n  [ServiceErrorType.VALIDATION]: 400,\n  [ServiceErrorType.UNAUTHORIZED]: 401,\n  [ServiceErrorType.FORBIDDEN]: 403,\n  [ServiceErrorType.NOT_FOUND]: 404,\n  [ServiceErrorType.CONFLICT]: 409,\n  [ServiceErrorType.INTERNAL]: 500,\n  [ServiceErrorType.UNKNOWN]: 500\n} as const;\n\n/**\n * Query options for service operations\n */\nexport interface QueryOptions {\n  limit?: number;\n  offset?: number;\n  sort?: {\n    field: string;\n    direction: 'asc' | 'desc';\n  };\n  filter?: Record<string, unknown>;\n}\n\n/**\n * Query result with pagination info\n */\nexport interface QueryResult<T> {\n  items: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n  totalPages: number;\n}\n\n/**\n * Helper type for OpenAPI route responses\n */\nexport type RouteResponse<\n  T,\n  E extends ServiceErrorType = ServiceErrorType.INTERNAL\n> = {\n  200: SuccessResponse<T>;\n} & {\n  [K in (typeof ErrorTypeToStatus)[E]]: ErrorResponse<E>;\n};\n\n/**\n * Helper to create a success response with literal true\n */\nexport function createSuccessResponse<T>(data: T): SuccessResponse<T> {\n  return {\n    success: true as const,\n    data\n  };\n}\n\n/**\n * Helper to create an error response with literal false\n */\nexport function createErrorResponse<E extends ServiceErrorType>(\n  type: E,\n  message: string\n): ErrorResponse<E> {\n  return {\n    success: false as const,\n    error: {\n      type,\n      message\n    }\n  };\n} ", "import { z } from 'zod';\nimport type { ServiceErrorType } from './services';\nimport type { SuccessResponse, ErrorResponse } from './services';\nimport { ErrorTypeToStatus } from './services';\n\n/**\n * OpenAPI content type mapping\n */\nexport type OpenAPIContent<T> = {\n  'application/json': {\n    schema: z.ZodType<T>;\n  };\n};\n\n/**\n * OpenAPI response with status code\n */\nexport type OpenAPIResponse<T, Status extends number> = {\n  description: string;\n  content: OpenAPIContent<T>;\n};\n\n/**\n * Maps error types to their OpenAPI response definitions\n */\nexport type ErrorResponseMapping<E extends ServiceErrorType> = {\n  [Status in (typeof ErrorTypeToStatus)[E]]: OpenAPIResponse<ErrorResponse<E>, Status>;\n};\n\n/**\n * OpenAPI route success response\n */\nexport type SuccessResponseMapping<T, Status extends number = 200> = {\n  [S in Status]: OpenAPIResponse<SuccessResponse<T>, S>;\n};\n\n/**\n * Complete OpenAPI route response mapping\n */\nexport type OpenAPIRouteResponse<\n  T,\n  E extends ServiceErrorType = ServiceErrorType.INTERNAL\n> = SuccessResponseMapping<T> & ErrorResponseMapping<E>;\n\n/**\n * Helper to create a success response schema\n */\nexport function createSuccessSchema<T>(schema: z.ZodType<T>) {\n  return z.object({\n    success: z.literal(true),\n    data: schema\n  }) as z.ZodType<SuccessResponse<T>>;\n}\n\n/**\n * Helper to create an error response schema\n */\nexport function createErrorSchema<E extends ServiceErrorType>(type: E) {\n  return z.object({\n    success: z.literal(false),\n    error: z.object({\n      type: z.literal(type),\n      message: z.string()\n    })\n  }) as z.ZodType<ErrorResponse<E>>;\n}\n\n/**\n * Helper to create a complete route response schema\n */\nexport function createRouteResponse<T, E extends ServiceErrorType = ServiceErrorType.INTERNAL>(\n  successSchema: z.ZodType<T>,\n  errorType: E,\n  options: {\n    successStatus?: 200 | 201;\n    successDescription?: string;\n    errorDescription?: string;\n  } = {}\n) {\n  const {\n    successStatus = 200,\n    successDescription = 'Successful response',\n    errorDescription = 'Error response'\n  } = options;\n\n  const responses = {\n    [successStatus]: {\n      description: successDescription,\n      content: {\n        'application/json': {\n          schema: createSuccessSchema(successSchema)\n        }\n      }\n    },\n    [ErrorTypeToStatus[errorType]]: {\n      description: errorDescription,\n      content: {\n        'application/json': {\n          schema: createErrorSchema(errorType)\n        }\n      }\n    }\n  } as const;\n\n  return responses;\n} ", "import { z } from 'zod';\nimport { DomainSchema } from '@repo/schema';\nimport type { User, Project, Task } from '@repo/schema';\n\n/**\n * Type guard for errors\n */\nexport function isError(value: unknown): value is Error {\n  return value instanceof Error;\n}\n\n/**\n * Type guard for plain objects\n */\nexport function isPlainObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n/**\n * Type guard for checking if an object has a property\n */\nexport function hasProperty<K extends string>(obj: unknown, key: K): obj is { [P in K]: unknown } {\n  return isPlainObject(obj) && key in obj;\n}\n\n/**\n * Type guard for user data\n */\nexport function isUserData(data: unknown): data is User {\n  return DomainSchema.User.safeParse(data).success;\n}\n\n/**\n * Type guard for project data\n */\nexport function isProjectData(data: unknown): data is Project {\n  return DomainSchema.Project.safeParse(data).success;\n}\n\n/**\n * Type guard for task data\n */\nexport function isTaskData(data: unknown): data is Task {\n  return DomainSchema.Task.safeParse(data).success;\n}\n\n/**\n * Create a type guard function for a Zod schema\n */\nexport function createTypeGuard<T>(schema: z.ZodSchema<T>) {\n  return (data: unknown): data is T => schema.safeParse(data).success;\n}\n\n/**\n * Type guard for checking if a value is a Record of a specific type\n */\nexport function isRecordOf<T>(value: unknown, itemGuard: (item: unknown) => item is T): value is Record<string, T> {\n  if (!isPlainObject(value)) return false;\n  return Object.values(value).every(itemGuard);\n}\n\n// Create type guards for each schema\nexport const createUserGuard = () => createTypeGuard(DomainSchema.User);\nexport const createProjectGuard = () => createTypeGuard(DomainSchema.Project);\nexport const createTaskGuard = () => createTypeGuard(DomainSchema.Task);\n\n// Cloudflare-specific bindings type guards\nexport function isDurableObjectNamespace(value: unknown): value is DurableObjectNamespace {\n  return isPlainObject(value) && \n    'newUniqueId' in value &&\n    'idFromName' in value &&\n    'idFromString' in value;\n}\n\nexport function isKVNamespace(value: unknown): value is KVNamespace {\n  return isPlainObject(value) && \n    'get' in value &&\n    'put' in value &&\n    'delete' in value;\n}\n\nexport function isR2Bucket(value: unknown): value is R2Bucket {\n  return isPlainObject(value) && \n    'get' in value &&\n    'put' in value &&\n    'delete' in value &&\n    'head' in value;\n}\n\nexport function isD1Database(value: unknown): value is D1Database {\n  return isPlainObject(value) && \n    'prepare' in value &&\n    'batch' in value &&\n    'exec' in value;\n}\n\nexport function isFetcher(value: unknown): value is Fetcher {\n  return isPlainObject(value) && 'fetch' in value;\n}\n\nexport function isQueue(value: unknown): value is Queue {\n  return isPlainObject(value) && 'send' in value;\n} ", "import { z } from 'zod';\nimport { DomainSchema } from '@repo/schema';\nimport type { User, Project, Task } from '@repo/schema';\n\n/**\n * Validation result type\n */\nexport type ValidationResult<T> = {\n  success: true;\n  data: T;\n} | {\n  success: false;\n  error: string;\n};\n\n/**\n * Helper to validate with Zod schema\n */\nexport function validateWithSchema<T>(schema: z.ZodType<T>, value: unknown): ValidationResult<T> {\n  const result = schema.safeParse(value);\n  if (result.success) {\n    return {\n      success: true as const,\n      data: result.data\n    };\n  }\n  return {\n    success: false as const,\n    error: result.error.message\n  };\n}\n\n/**\n * Validate user data\n */\nexport function validateUserData(data: unknown): ValidationResult<User> {\n  return validateWithSchema(DomainSchema.User, data);\n}\n\n/**\n * Validate project data\n */\nexport function validateProjectData(data: unknown): ValidationResult<Project> {\n  return validateWithSchema(DomainSchema.Project, data);\n}\n\n/**\n * Validate task data\n */\nexport function validateTaskData(data: unknown): ValidationResult<Task> {\n  return validateWithSchema(DomainSchema.Task, data);\n}\n\n/**\n * Create validator function for schema\n */\nexport function createValidator<T>(schema: z.ZodSchema<T>) {\n  return (data: unknown): ValidationResult<T> => validateWithSchema(schema, data);\n}\n\n// Create validators for each schema\nexport const createUserValidator = () => createValidator(DomainSchema.User);\nexport const createProjectValidator = () => createValidator(DomainSchema.Project);\nexport const createTaskValidator = () => createValidator(DomainSchema.Task); ", "import { z } from 'zod';\nimport { DomainSchema } from '@repo/schema';\n\n// Re-export validation schemas\nexport const {\n  // Base schemas\n  Entity: baseValidation,\n  \n  // User schemas\n  User: userValidation,\n  \n  // Project schemas\n  Project: projectValidation,\n  ProjectSettings: projectSettingsValidation,\n  \n  // Task schemas\n  Task: taskValidation\n} = DomainSchema;\n\n// Re-export validation types\nexport type {\n  // Base types\n  Entity as ValidatedBase,\n  \n  // User types\n  User as ValidatedUser,\n  \n  // Project types\n  Project as ValidatedProject,\n  ProjectSettings as ValidatedProjectSettings,\n  \n  // Task types\n  Task as ValidatedTask\n} from '@repo/schema'; ", "import { z } from 'zod';\nimport { TypeErrorCategory } from './types';\nimport type { ValidationError } from '../serialization/core/types';\nimport type { ErrorContext, BaseError } from './types';\n\n/**\n * Detailed error context\n */\nexport interface TypeErrorContext {\n  category: TypeErrorCategory;\n  operation: string;\n  table?: string;\n  data?: unknown;\n  path?: (string | number)[];\n  timestamp: number;\n  duration?: number;\n  context?: ErrorContext;\n}\n\n/**\n * Error tracking metrics\n */\nexport interface TypeSafetyMetrics {\n  totalErrors: number;\n  errorsByCategory: Record<TypeErrorCategory, number>;\n  averageValidationTime: number;\n  errorRate: number;\n  lastError?: TypeErrorContext;\n}\n\n/**\n * Error tracking configuration\n */\nexport interface ErrorTrackingConfig {\n  enabled: boolean;\n  sampleRate?: number;\n  maxErrors?: number;\n  onError?: (context: TypeErrorContext) => void;\n}\n\n/**\n * Error handler interface\n */\nexport interface ErrorHandler {\n  trackError(error: Error, operation: string, context?: Record<string, unknown>): void;\n  getMetrics(): TypeSafetyMetrics;\n  resetMetrics(): void;\n}\n\n/**\n * Validate error details schema\n */\nconst errorDetailsSchema = z.object({\n  category: z.nativeEnum(TypeErrorCategory).optional(),\n  operation: z.string().optional(),\n  table: z.string().optional(),\n  data: z.unknown().optional(),\n  path: z.array(z.union([z.string(), z.number()])).optional(),\n  timestamp: z.number().optional(),\n  duration: z.number().optional()\n});\n\n/**\n * Type guard for error context details\n */\nfunction isValidErrorDetails(details: unknown): details is Partial<TypeErrorContext> {\n  return errorDetailsSchema.safeParse(details).success;\n}\n\n/**\n * Validate error tracking configuration\n */\nconst errorTrackingConfigSchema = z.object({\n  enabled: z.boolean(),\n  sampleRate: z.number().min(0).max(1).optional(),\n  maxErrors: z.number().int().positive().optional(),\n  onError: z.function().args(z.custom<TypeErrorContext>()).returns(z.void()).optional()\n});\n\n/**\n * Initialize error category counters\n */\nfunction initializeErrorCounters(): Record<TypeErrorCategory, number> {\n  return Object.values(TypeErrorCategory).reduce((acc, category) => {\n    acc[category] = 0;\n    return acc;\n  }, Object.create(null));\n}\n\n/**\n * Type safety error tracker\n */\nexport class TypeSafetyTracker {\n  private errors: TypeErrorContext[] = [];\n  private startTime: number = Date.now();\n  private validationTimes: number[] = [];\n  private config: ErrorTrackingConfig;\n\n  constructor(config: ErrorTrackingConfig) {\n    // Validate config\n    const validatedConfig = errorTrackingConfigSchema.parse(config);\n    \n    // Create config with type safety\n    this.config = {\n      enabled: validatedConfig.enabled,\n      sampleRate: validatedConfig.sampleRate !== undefined ? validatedConfig.sampleRate : 1,\n      maxErrors: validatedConfig.maxErrors !== undefined ? validatedConfig.maxErrors : 1000,\n      onError: validatedConfig.onError\n    } satisfies ErrorTrackingConfig;\n  }\n\n  /**\n   * Track a type safety error\n   */\n  trackError(\n    category: TypeErrorCategory,\n    operation: string,\n    details: unknown = {}\n  ): void {\n    if (!this.config.enabled || Math.random() > (this.config.sampleRate || 1)) {\n      return;\n    }\n\n    // Create base context with required fields\n    const baseContext = {\n      category,\n      operation,\n      timestamp: Date.now()\n    };\n\n    // Validate and merge additional details\n    const validatedDetails = errorDetailsSchema.safeParse(details);\n    const context: TypeErrorContext = {\n      ...baseContext,\n      ...(validatedDetails.success ? validatedDetails.data : {})\n    };\n\n    this.errors.push(context);\n    if (this.errors.length > (this.config.maxErrors || 1000)) {\n      this.errors.shift();\n    }\n\n    if (this.config.onError) {\n      try {\n        this.config.onError(context);\n      } catch (error) {\n        console.error('Error in onError callback:', error);\n      }\n    }\n  }\n\n  /**\n   * Track validation performance\n   */\n  trackValidation(duration: number): void {\n    if (typeof duration !== 'number' || isNaN(duration) || duration < 0) {\n      console.warn('Invalid validation duration:', duration);\n      return;\n    }\n\n    this.validationTimes.push(duration);\n    if (this.validationTimes.length > 1000) {\n      this.validationTimes.shift();\n    }\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): TypeSafetyMetrics {\n    const totalErrors = this.errors.length;\n    const errorsByCategory = Object.values(TypeErrorCategory).reduce<Record<TypeErrorCategory, number>>(\n      (acc, category) => {\n        acc[category] = this.errors.filter(e => e.category === category).length;\n        return acc;\n      },\n      initializeErrorCounters()\n    );\n\n    const avgValidationTime = this.validationTimes.length\n      ? this.validationTimes.reduce((a, b) => a + b, 0) / this.validationTimes.length\n      : 0;\n\n    const timespan = Date.now() - this.startTime;\n    const errorRate = totalErrors / (timespan / (1000 * 60 * 60)); // Errors per hour\n\n    return {\n      totalErrors,\n      errorsByCategory,\n      averageValidationTime: avgValidationTime,\n      errorRate,\n      lastError: this.errors[this.errors.length - 1]\n    };\n  }\n\n  /**\n   * Get error history with type-safe filtering\n   */\n  getErrorHistory(\n    options: {\n      category?: TypeErrorCategory;\n      table?: string;\n      limit?: number;\n      since?: number;\n    } = {}\n  ): TypeErrorContext[] {\n    // Validate options\n    const validatedOptions = {\n      category: options.category,\n      table: typeof options.table === 'string' ? options.table : undefined,\n      limit: typeof options.limit === 'number' && options.limit > 0 ? options.limit : 100,\n      since: typeof options.since === 'number' ? options.since : 0\n    };\n\n    let filtered = this.errors;\n\n    if (validatedOptions.category) {\n      filtered = filtered.filter(e => e.category === validatedOptions.category);\n    }\n    if (validatedOptions.table) {\n      filtered = filtered.filter(e => e.table === validatedOptions.table);\n    }\n    filtered = filtered.filter(e => e.timestamp >= validatedOptions.since);\n\n    return filtered.slice(-validatedOptions.limit);\n  }\n\n  /**\n   * Clear error history\n   */\n  clearHistory(): void {\n    this.errors = [];\n    this.validationTimes = [];\n    this.startTime = Date.now();\n  }\n} ", "/**\n * Error categories for type validation\n */\nexport enum TypeErrorCategory {\n  VALIDATION = 'validation',\n  SERIALIZATION = 'serialization',\n  TYPE_SAFETY = 'type_safety'\n}\n\n/**\n * Error context for tracking where errors occur\n */\nexport enum ErrorContext {\n  STORE_VALIDATION = 'store_validation',\n  STORE_INITIALIZATION = 'store_initialization',\n  WEBSOCKET_CONNECTION = 'websocket_connection',\n  WEBSOCKET_MESSAGE = 'websocket_message',\n  WEBSOCKET_BROADCAST = 'websocket_broadcast',\n  WEBSOCKET_ERROR = 'websocket_error',\n  WEBSOCKET_CLOSE = 'websocket_close'\n}\n\n/**\n * Base error interface\n */\nexport interface BaseError {\n  category: TypeErrorCategory;\n  message: string;\n  path?: string[];\n  value?: unknown;\n  timestamp?: number;\n  context?: ErrorContext;\n}\n\n/**\n * Validation error interface\n */\nexport interface ValidationError extends BaseError {\n  category: TypeErrorCategory.VALIDATION;\n}\n\n/**\n * Serialization error interface\n */\nexport interface SerializationError extends BaseError {\n  category: TypeErrorCategory.SERIALIZATION;\n}\n\n/**\n * Type safety error interface\n */\nexport interface TypeSafetyError extends BaseError {\n  category: TypeErrorCategory.TYPE_SAFETY;\n}\n\n/**\n * Error metrics for tracking validation and runtime errors\n */\nexport interface ErrorMetrics {\n  validationErrors: number;\n  runtimeErrors: number;\n  lastError?: BaseError;\n} ", "import { z } from 'zod';\nimport type { Result, SerializationError, SerializationOptions } from './types';\n\nconst dateSchema = z.date();\nconst objectSchema = z.record(z.unknown());\n\n/**\n * Type guard for Date objects\n */\nexport function isDate(value: unknown): value is Date {\n  return dateSchema.safeParse(value).success;\n}\n\n/**\n * Type guard for objects\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return objectSchema.safeParse(value).success;\n}\n\n/**\n * Safely stringify data to JSON\n */\nexport function safeStringify(data: unknown, options: SerializationOptions = {}): Result<string> {\n  try {\n    const serialized = JSON.stringify(data, (key, value) => {\n      if (isDate(value)) {\n        return { __type: 'Date', value: value.toISOString() };\n      }\n      return value;\n    }, options.pretty ? 2 : undefined);\n\n    return { success: true, data: serialized };\n  } catch (error) {\n    const serializationError: SerializationError = {\n      type: 'serialization_error',\n      message: error instanceof Error ? error.message : 'Unknown serialization error',\n      details: { data }\n    };\n    return { success: false, error: serializationError };\n  }\n}\n\ninterface ParseSuccess<T> {\n  success: true;\n  data: T;\n}\n\ninterface ParseError {\n  success: false;\n  error: Error;\n}\n\ntype ParseResult<T> = ParseSuccess<T> | ParseError;\n\n/**\n * Safely parse a JSON string with proper error handling and typing\n */\nexport function safeParse<T>(data: string, validate?: (parsed: unknown) => parsed is T): Result<T> {\n  try {\n    const parsed = JSON.parse(data, (key, value) => {\n      if (isObject(value) && value.__type === 'Date') {\n        const dateStr = value.value;\n        if (typeof dateStr === 'string') {\n          const date = new Date(dateStr);\n          if (!isNaN(date.getTime())) {\n            return date;\n          }\n        }\n      }\n      return value;\n    });\n\n    if (validate) {\n      if (!validate(parsed)) {\n        const validationError: SerializationError = {\n          type: 'validation_error',\n          message: 'Data validation failed',\n          details: { data: parsed }\n        };\n        return { success: false, error: validationError };\n      }\n      return { success: true, data: parsed };\n    }\n\n    // If no validator is provided, we can only guarantee it's of type unknown\n    const validationError: SerializationError = {\n      type: 'validation_error',\n      message: 'No validator provided for type checking',\n      details: { data: parsed }\n    };\n    return { success: false, error: validationError };\n  } catch (error) {\n    const parseError: SerializationError = {\n      type: 'parse_error',\n      message: error instanceof Error ? error.message : 'Unknown parse error',\n      details: { data }\n    };\n    return { success: false, error: parseError };\n  }\n}\n\n/**\n * Validate data against a schema\n */\nexport function validateData<T>(data: unknown, schema: z.ZodType<T>): Result<T> {\n  const result = schema.safeParse(data);\n  if (!result.success) {\n    const validationError: SerializationError = {\n      type: 'validation_error',\n      message: 'Schema validation failed',\n      details: { errors: result.error.errors }\n    };\n    return { success: false, error: validationError };\n  }\n  return { success: true, data: result.data };\n}\n\n/**\n * Type guard for schema-validated data\n */\nexport function isValidData<T>(data: unknown, schema: z.ZodType<T>): data is T {\n  return schema.safeParse(data).success;\n} "],
  "mappings": "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",
  "names": ["ServiceErrorType", "DomainSchema", "DomainSchema", "z", "TypeErrorCategory", "ErrorContext", "z", "z", "z", "validationError"]
}
